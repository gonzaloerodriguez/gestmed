name: Daily Database Backup (Network Fixed)

on:
  schedule:
    - cron: "0 2 * * *" # Todos los días a las 2:00 AM UTC
  workflow_dispatch:

jobs:
  run_db_backup:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    permissions:
      contents: write
    env:
      SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL }}
      SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
      SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}
      BACKUP_ENCRYPTION_KEY: ${{ secrets.BACKUP_ENCRYPTION_KEY }}
      BACKUP_ENABLED: true

    steps:
      - name: Check if backups are enabled
        run: |
          if [ "$BACKUP_ENABLED" != "true" ]; then
            echo "Backups are disabled. Exiting workflow."
            exit 0
          fi

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Supabase CLI (Official Action)
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Verify Supabase CLI installation
        run: |
          supabase --version
          echo "Supabase CLI instalado correctamente"

      - name: Login to Supabase
        run: |
          supabase login --token "$SUPABASE_ACCESS_TOKEN"

      - name: Create timestamp folder
        run: |
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)
          mkdir -p backups/$TIMESTAMP
          echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
          echo "Carpeta creada: backups/$TIMESTAMP"

      - name: Backup with debug and IPv4 preference
        run: |
          echo "Intentando backup con configuración de red optimizada..."

          # Configurar preferencia IPv4
          export PGCONNECT_TIMEOUT=30
          export PGCOMMAND_TIMEOUT=300

          # Intentar backup de roles con debug
          echo "Creando backup de roles..."
          supabase db dump --debug --db-url "$SUPABASE_DB_URL" -f backups/$TIMESTAMP/roles.sql --role-only || {
            echo "Error en backup de roles, continuando..."
          }

          # Intentar backup de schema con debug
          echo "Creando backup de schema..."
          supabase db dump --debug --db-url "$SUPABASE_DB_URL" -f backups/$TIMESTAMP/schema.sql || {
            echo "Error en backup de schema, continuando..."
          }

          # Intentar backup de datos con debug
          echo "Creando backup de datos..."
          supabase db dump --debug --db-url "$SUPABASE_DB_URL" -f backups/$TIMESTAMP/data.sql --data-only --use-copy || {
            echo "Error en backup de datos, continuando..."
          }

          # Intentar backup completo con debug
          echo "Creando backup completo..."
          supabase db dump --debug --db-url "$SUPABASE_DB_URL" -f backups/$TIMESTAMP/complete_backup.sql || {
            echo "Error en backup completo"
          }

      - name: Alternative backup method (PostgreSQL direct)
        run: |
          echo "Intentando método alternativo con PostgreSQL directo..."

          # Instalar cliente PostgreSQL
          sudo apt-get update
          sudo apt-get install -y postgresql-client

          # Extraer componentes de la URL
          DB_URL="$SUPABASE_DB_URL"

          # Método más robusto para extraer componentes
          DB_USER=$(echo $DB_URL | sed -n 's/.*:\/\/$$[^:]*$$:.*/\1/p')
          DB_PASSWORD=$(echo $DB_URL | sed -n 's/.*:\/\/[^:]*:$$[^@]*$$@.*/\1/p')
          DB_HOST=$(echo $DB_URL | sed -n 's/.*@$$[^:]*$$:.*/\1/p')
          DB_PORT=$(echo $DB_URL | sed -n 's/.*:$$[0-9]*$$\/.*/\1/p')
          DB_NAME=$(echo $DB_URL | sed -n 's/.*\/$$[^?]*$$.*/\1/p')

          echo "Componentes extraídos:"
          echo "Usuario: $DB_USER"
          echo "Host: $DB_HOST"
          echo "Puerto: $DB_PORT"
          echo "Base de datos: $DB_NAME"

          # Crear archivo .pgpass
          echo "$DB_HOST:$DB_PORT:$DB_NAME:$DB_USER:$DB_PASSWORD" > ~/.pgpass
          chmod 600 ~/.pgpass

          # Configurar variables de entorno para PostgreSQL
          export PGHOST=$DB_HOST
          export PGPORT=$DB_PORT
          export PGUSER=$DB_USER
          export PGDATABASE=$DB_NAME
          export PGPASSFILE=~/.pgpass
          export PGCONNECT_TIMEOUT=30

          # Intentar backup alternativo
          echo "Intentando backup con pg_dump..."
          pg_dump -h $DB_HOST -p $DB_PORT -U $DB_USER -d $DB_NAME -f backups/$TIMESTAMP/alternative_backup.sql || {
            echo "Error en backup alternativo con pg_dump"
          }

      - name: Verify backups
        run: |
          echo "Verificando archivos de backup creados..."
          ls -la backups/$TIMESTAMP/ || echo "No se encontró la carpeta de backups"

          # Verificar si al menos un archivo se creó
          if [ -n "$(ls -A backups/$TIMESTAMP/ 2>/dev/null)" ]; then
            echo "✅ Se crearon archivos de backup:"
            du -h backups/$TIMESTAMP/*
          else
            echo "❌ No se crearon archivos de backup"
            echo "Creando archivo de error para documentar el problema..."
            mkdir -p backups/$TIMESTAMP
            echo "Error: No se pudo conectar a la base de datos desde GitHub Actions" > backups/$TIMESTAMP/error.txt
            echo "Timestamp: $(date)" >> backups/$TIMESTAMP/error.txt
            echo "URL utilizada: $SUPABASE_DB_URL" >> backups/$TIMESTAMP/error.txt
          fi

      - name: Compress backups
        run: |
          echo "Comprimiendo backups..."
          cd backups
          tar -czf backup_$TIMESTAMP.tar.gz $TIMESTAMP/
          echo "Backup comprimido creado: backup_$TIMESTAMP.tar.gz"
          ls -la backup_$TIMESTAMP.tar.gz
          echo "Tamaño del archivo comprimido: $(du -h backup_$TIMESTAMP.tar.gz | cut -f1)"

      - name: Encrypt backup
        run: |
          echo "Encriptando backup..."
          cd backups
          gpg --symmetric --cipher-algo AES256 --compress-algo 1 --s2k-mode 3 --s2k-digest-algo SHA512 --s2k-count 65536 --quiet --batch --passphrase "$BACKUP_ENCRYPTION_KEY" backup_$TIMESTAMP.tar.gz
          rm backup_$TIMESTAMP.tar.gz
          echo "Backup encriptado correctamente: backup_$TIMESTAMP.tar.gz.gpg"
          ls -la backup_$TIMESTAMP.tar.gz.gpg

      - name: Upload backup to release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: backup-${{ env.TIMESTAMP }}
          name: Database Backup ${{ env.TIMESTAMP }}
          files: backups/backup_${{ env.TIMESTAMP }}.tar.gz.gpg
          body: |
            🗄️ **Backup Automático de Base de Datos**

            **Información del Backup:**
            - 📅 Fecha: $(date +%Y-%m-%d)
            - ⏰ Hora: $(date +%H:%M:%S) UTC
            - 🏃 Run: ${{ github.run_number }}
            - 🔧 Método: Supabase CLI + PostgreSQL directo

            **Estado del Backup:**
            - Se intentaron múltiples métodos de backup
            - Verificar contenido del archivo para confirmar éxito

            **Para restaurar:**
            1. Descargar el archivo .gpg
            2. Desencriptar: `gpg --decrypt backup_${{ env.TIMESTAMP }}.tar.gz.gpg > backup.tar.gz`
            3. Extraer: `tar -xzf backup.tar.gz`
            4. Revisar archivos disponibles en la carpeta extraída
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Install GitHub CLI and cleanup old backups
        run: |
          echo "Instalando GitHub CLI..."
          curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
          sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
          sudo apt update
          sudo apt install gh -y

          echo "Limpiando backups antiguos..."
          gh auth login --with-token <<< "${{ secrets.GITHUB_TOKEN }}"

          # Mantener solo los últimos 30 backups
          RELEASES_TO_DELETE=$(gh release list --limit 50 | grep "backup-" | tail -n +31 | awk '{print $1}')

          if [ -n "$RELEASES_TO_DELETE" ]; then
            echo "Eliminando releases antiguos:"
            echo "$RELEASES_TO_DELETE"
            echo "$RELEASES_TO_DELETE" | xargs -I {} gh release delete {} --yes
            echo "Limpieza completada"
          else
            echo "No hay releases antiguos para eliminar"
          fi

      - name: Cleanup local files
        run: |
          echo "Limpiando archivos locales..."
          rm -rf backups/
          echo "Limpieza local completada"

      - name: Backup summary
        run: |
          echo "📋 Resumen del proceso de backup:"
          echo "   - Timestamp: $TIMESTAMP"
          echo "   - Release: backup-$TIMESTAMP"
          echo "   - Se intentaron múltiples métodos de backup"
          echo "   - Verificar el contenido del release para confirmar éxito"
          echo "   - Si hay problemas de conectividad, revisar configuración de red de Supabase"

# name: Daily Database Backup (Fixed)

# on:
#   schedule:
#     - cron: "0 2 * * *" # Todos los días a las 2:00 AM UTC
#   workflow_dispatch:

# jobs:
#   run_db_backup:
#     runs-on: ubuntu-latest
#     timeout-minutes: 15
#     permissions:
#       contents: write
#     env:
#       SUPABASE_DB_URL: ${{ secrets.SUPABASE_DB_URL }}
#       SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
#       SUPABASE_PROJECT_REF: ${{ secrets.SUPABASE_PROJECT_REF }}
#       BACKUP_ENCRYPTION_KEY: ${{ secrets.BACKUP_ENCRYPTION_KEY }}
#       BACKUP_ENABLED: true

#     steps:
#       - name: Check if backups are enabled
#         run: |
#           if [ "$BACKUP_ENABLED" != "true" ]; then
#             echo "Backups are disabled. Exiting workflow."
#             exit 0
#           fi

#       - name: Checkout repository
#         uses: actions/checkout@v4

#       - name: Setup Supabase CLI (Official Action)
#         uses: supabase/setup-cli@v1
#         with:
#           version: latest

#       - name: Verify Supabase CLI installation
#         run: |
#           supabase --version
#           echo "Supabase CLI instalado correctamente"

#       - name: Login to Supabase
#         run: |
#           # Forma correcta de pasar el token
#           supabase login --token "$SUPABASE_ACCESS_TOKEN"

#       - name: Test Supabase connection
#         run: |
#           echo "Verificando conexión con Supabase..."
#           supabase projects list

#       - name: Create timestamp folder
#         run: |
#           TIMESTAMP=$(date +%Y%m%d_%H%M%S)
#           mkdir -p backups/$TIMESTAMP
#           echo "TIMESTAMP=$TIMESTAMP" >> $GITHUB_ENV
#           echo "Carpeta creada: backups/$TIMESTAMP"

#       - name: Backup roles
#         run: |
#           echo "Creando backup de roles..."
#           supabase db dump --db-url "$SUPABASE_DB_URL" -f backups/$TIMESTAMP/roles.sql --role-only
#           echo "Backup de roles completado"

#       - name: Backup schema
#         run: |
#           echo "Creando backup de schema..."
#           supabase db dump --db-url "$SUPABASE_DB_URL" -f backups/$TIMESTAMP/schema.sql
#           echo "Backup de schema completado"

#       - name: Backup data
#         run: |
#           echo "Creando backup de datos..."
#           supabase db dump --db-url "$SUPABASE_DB_URL" -f backups/$TIMESTAMP/data.sql --data-only --use-copy
#           echo "Backup de datos completado"

#       - name: Create complete backup
#         run: |
#           echo "Creando backup completo..."
#           supabase db dump --db-url "$SUPABASE_DB_URL" -f backups/$TIMESTAMP/complete_backup.sql
#           echo "Backup completo creado"

#       - name: Verify backups
#         run: |
#           echo "Verificando archivos de backup..."
#           ls -la backups/$TIMESTAMP/
#           echo "Tamaños de archivos:"
#           du -h backups/$TIMESTAMP/*

#       - name: Compress backups
#         run: |
#           echo "Comprimiendo backups..."
#           cd backups
#           tar -czf backup_$TIMESTAMP.tar.gz $TIMESTAMP/
#           echo "Backup comprimido creado: backup_$TIMESTAMP.tar.gz"
#           ls -la backup_$TIMESTAMP.tar.gz
#           echo "Tamaño del archivo comprimido: $(du -h backup_$TIMESTAMP.tar.gz | cut -f1)"

#       - name: Encrypt backup
#         run: |
#           echo "Encriptando backup..."
#           cd backups
#           gpg --symmetric --cipher-algo AES256 --compress-algo 1 --s2k-mode 3 --s2k-digest-algo SHA512 --s2k-count 65536 --quiet --batch --passphrase "$BACKUP_ENCRYPTION_KEY" backup_$TIMESTAMP.tar.gz
#           rm backup_$TIMESTAMP.tar.gz
#           echo "Backup encriptado correctamente: backup_$TIMESTAMP.tar.gz.gpg"
#           ls -la backup_$TIMESTAMP.tar.gz.gpg

#       - name: Upload backup to release
#         uses: softprops/action-gh-release@v1
#         with:
#           tag_name: backup-${{ env.TIMESTAMP }}
#           name: Database Backup ${{ env.TIMESTAMP }}
#           files: backups/backup_${{ env.TIMESTAMP }}.tar.gz.gpg
#           body: |
#             🗄️ **Backup Automático de Base de Datos**

#             **Información del Backup:**
#             - 📅 Fecha: $(date +%Y-%m-%d)
#             - ⏰ Hora: $(date +%H:%M:%S) UTC
#             - 🏃 Run: ${{ github.run_number }}
#             - 🔧 Método: Supabase CLI oficial

#             **Contenido del Backup:**
#             - 👥 Roles y permisos (roles.sql)
#             - 🏗️ Esquema de base de datos (schema.sql)
#             - 📊 Datos completos (data.sql)
#             - 💾 Backup completo (complete_backup.sql)

#             **Seguridad:**
#             - 🔒 Archivo encriptado con AES256
#             - 🗜️ Comprimido con gzip

#             **Para restaurar:**
#             1. Descargar el archivo .gpg
#             2. Desencriptar: `gpg --decrypt backup_${{ env.TIMESTAMP }}.tar.gz.gpg > backup.tar.gz`
#             3. Extraer: `tar -xzf backup.tar.gz`
#             4. Restaurar según necesidad
#         env:
#           GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

#       - name: Install GitHub CLI and cleanup old backups
#         run: |
#           echo "Instalando GitHub CLI..."
#           curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
#           sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
#           echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
#           sudo apt update
#           sudo apt install gh -y

#           echo "Limpiando backups antiguos..."
#           # Forma correcta de pasar el token a GitHub CLI
#           gh auth login --with-token <<< "${{ secrets.GITHUB_TOKEN }}"

#           # Mantener solo los últimos 30 backups
#           RELEASES_TO_DELETE=$(gh release list --limit 50 | grep "backup-" | tail -n +31 | awk '{print $1}')

#           if [ -n "$RELEASES_TO_DELETE" ]; then
#             echo "Eliminando releases antiguos:"
#             echo "$RELEASES_TO_DELETE"
#             echo "$RELEASES_TO_DELETE" | xargs -I {} gh release delete {} --yes
#             echo "Limpieza completada"
#           else
#             echo "No hay releases antiguos para eliminar"
#           fi

#       - name: Cleanup local files
#         run: |
#           echo "Limpiando archivos locales..."
#           rm -rf backups/
#           echo "Limpieza local completada"

#       - name: Backup summary
#         run: |
#           echo "🎉 ¡Backup completado exitosamente!"
#           echo "📋 Resumen:"
#           echo "   - Timestamp: $TIMESTAMP"
#           echo "   - Release: backup-$TIMESTAMP"
#           echo "   - Archivos incluidos: roles.sql, schema.sql, data.sql, complete_backup.sql"
#           echo "   - Estado: Encriptado y subido a GitHub Releases"
#           echo "   - Backups antiguos: Limpiados (manteniendo últimos 30)"
